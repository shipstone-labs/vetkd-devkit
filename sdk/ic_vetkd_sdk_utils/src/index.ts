import { bls12_381 } from '@noble/curves/bls12-381';
import { ProjPointType } from '@noble/curves/abstract/weierstrass';
import { Fp, Fp2, Fp12 } from '@noble/curves/abstract/tower';
import { hash_to_field } from '@noble/curves/abstract/hash-to-curve';
import { shake256 } from '@noble/hashes/sha3';
import { hkdf } from '@noble/hashes/hkdf';
import { sha256 } from '@noble/hashes/sha256';

export type G1Point = ProjPointType<Fp>;
export type G2Point = ProjPointType<Fp2>;

const G1_BYTES = 48;
const G2_BYTES = 96;

/**
 * Transport Secret Key
 *
 * Applications using VetKD create an ephemeral transport secret key and send
 * the public key to the IC as part of their VetKD request. The returned VetKey
 * is encrypted, and can only be decrypted using the transport secret key.
 */
export class TransportSecretKey {
    readonly #sk: Uint8Array;
    readonly #pk: G1Point;

    /**
     * Construct a new TransportSecretKey from a bytestring
     *
     * The bytestring should be randomly generated by a cryptographically
     * secure random number generator.
     *
     * For most applications, prefer using the static method random
     */
    constructor(sk: Uint8Array) {
        if(sk.length !== 32) {
            throw new Error("Invalid size for transport secret key");
        }

        this.#sk = sk;

        const pk = bls12_381.G1.ProjectivePoint.fromPrivateKey(this.#sk);
        this.#pk = pk;
    }

    /**
     * Create a random transport secret key
     */
    static random() {
        return new TransportSecretKey(bls12_381.utils.randomPrivateKey());
    }

    /**
     * Return the encoding of the transport public key; this value is
     * sent to the IC
     */
    publicKeyBytes(): Uint8Array {
        return this.#pk.toRawBytes(true);
    }

    /**
     * Return the transport secret key value
     *
     * Applications would not normally need to call this
     */
    getSecretKey(): Uint8Array {
        return this.#sk;
    }
}

/**
 * VetKD derived public key
 *
 * An unencrypted VetKey is a BLS signature generated with a canister-specific
 * key. This type represents such keys.
 */
export class DerivedPublicKey {
    readonly #pk: G2Point;

    /**
     * Read a DerivedPublicKey from the bytestring encoding
     *
     * Normally the bytes provided here will have been returned by
     * the `vetkd_public_key` management canister interface.
     */
    constructor(bytes: Uint8Array) {
        this.#pk = bls12_381.G2.ProjectivePoint.fromHex(bytes);
    }

    /**
     * Return the bytestring encoding of the derived public key
     *
     * Applications would not normally need to call this, unless they
     * are using VetKD for creating a random beacon, in which case
     * these bytes are used by anyone verifying the beacon.
     */
    publicKeyBytes(): Uint8Array {
        return this.#pk.toRawBytes(true);
    }

    /**
     * @internal getter returning the point element of the derived public key
     *
     * Applications would not normally need to call this
     */
    getPoint(): G2Point {
        return this.#pk;
    }
}

/**
 * Hash an input to a scalar in the BLS12-381 group
 *
 * This is useful if you want to derive a BLS12-381 secret key from some other
 * input data, but this is not a common operation.
 */
export function hashToScalar(input: Uint8Array, domainSep: string): bigint {
    const params = {
      p: bls12_381.params.r,
      m: 1,
      DST: domainSep,
    };

    // @ts-expect-error (https://github.com/paulmillr/noble-curves/issues/179)
    const options = Object.assign({}, bls12_381.G2.CURVE.htfDefaults, params);

    const scalars = hash_to_field(input, 1, options);

    return scalars[0][0];
}

/**
 * @internal derive a symmetric key from the provided input
 *
 * The `input` parameter should be a sufficiently long random input.
 *
 * The `domainSep` parameter should be a string unique to your application and
 * also your usage of the resulting key. For example say your application
 * "my-app" is deriving two keys, one for usage "foo" and the other for
 * "bar". You might use as domain separators "my-app-foo" and "my-app-bar".
 */
export function deriveSymmetricKey(input: Uint8Array, domainSep: Uint8Array | string, outputLength: number): Uint8Array {
    const no_salt = new Uint8Array();
    return hkdf(sha256, input, no_salt, domainSep, outputLength);
}

/**
 * @internal hash a derived public key plus a message into the BLS12-381 G1 group
 *
 * This is not normally needed by applications using VetKD.
 */
export function augmentedHashToG1(pk: DerivedPublicKey, message: Uint8Array): G1Point {
    const domainSep = "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_AUG_";
    const pkbytes = pk.publicKeyBytes();
    const input = new Uint8Array([...pkbytes, ...message]);
    const pt = bls12_381.G1.ProjectivePoint.fromAffine(bls12_381.G1.hashToCurve(input, {
        DST: domainSep
    }).toAffine());

    return pt;
}

/**
 * A VetKey (verifiably encrypted threshold key)
 *
 * This is the end product of executing the VetKD protocol.
 *
 * Internally a VetKey is a valid BLS signature for the bytestring
 * `derivation_id` which provided when calling the `vetkd_derive_encrypted_key`
 * management canister interface.
 *
 * For certain usages, such as a beacon, the VetKey is actually used directly.
 * However the more common usage of VetKD protocol is for distribution of
 * encryption keys (eg AES keys to encrypt content).
 */
export class VetKey {
    readonly #pt: G1Point;
    readonly #bytes: Uint8Array;

    /**
     * Return the VetKey bytes, aka the BLS signature
     *
     * Use the raw bytes only if your design makes use of the fact that VetKeys
     * are BLS signatures (eg for random beacon or threshold BLS signature
     * generation). If you are using VetKD for key distribution, instead use
     * deriveSymmetricKey or asHkdfCryptoKey
     */
    signatureBytes(): Uint8Array {
        return this.#bytes;
    }

    /**
     * Derive a symmetric key of the requested length from the VetKey
     *
     * The `domainSep` parameter should be a string unique to your application and
     * also your usage of the resulting key. For example say your application
     * "my-app" is deriving two keys, one for usage "foo" and the other for
     * "bar". You might use as domain separators "my-app-foo" and "my-app-bar".
     */
    deriveSymmetricKey(domainSep: Uint8Array | string, outputLength: number): Uint8Array {
        return deriveSymmetricKey(this.#bytes, domainSep, outputLength);
    }

    /**
     * Return a WebCrypto CryptoKey handle suitable for further key derivation
     *
     * The CryptoKey is not exportable
     */
    async asHkdfCryptoKey(): Promise<CryptoKey> {
        const exportable = false;
        return window.crypto.subtle.importKey("raw", this.#bytes, "HKDF", exportable, ["deriveKey"]);
    }

    /**
     * Deserialize a VetKey from the 48 byte encoding of the BLS signature
     *
     * This deserializes the same value as returned by signatureBytes
     */
    static deserialize(bytes: Uint8Array): VetKey {
        return new VetKey(bls12_381.G1.ProjectivePoint.fromHex(bytes));
    }

    /**
     * @internal getter returning the point object of the VetKey
     *
     * Applications would not usually need to call this
     */
    getPoint(): G1Point {
        return this.#pt;
    }

    /**
     * @internal constructor
     *
     * This is public for typing reasons but there is no reason for an application
     * to call this constructor.
     */
    constructor(pt: G1Point) {
        this.#pt = pt;
        this.#bytes = pt.toRawBytes(true);
    }
}

export class EncryptedKey {
    readonly #c1: G1Point;
    readonly #c2: G2Point;
    readonly #c3: G1Point;

    /**
     * Parse an encrypted key returned by the `vetkd_derive_encrypted_key`
     * managment canister interface
     */
    constructor(bytes: Uint8Array) {
        if(bytes.length !== G1_BYTES + G2_BYTES + G1_BYTES) {
            throw new Error("Invalid EncryptedKey serialization");
        }

        this.#c1 = bls12_381.G1.ProjectivePoint.fromHex(bytes.subarray(0, G1_BYTES));
        this.#c2 = bls12_381.G2.ProjectivePoint.fromHex(bytes.subarray(G1_BYTES, G1_BYTES + G2_BYTES));
        this.#c3 = bls12_381.G1.ProjectivePoint.fromHex(bytes.subarray(G1_BYTES + G2_BYTES));
    }

    /**
     * Decrypt the encrypted key returning a VetKey
     */
    decryptAndVerify(tsk: TransportSecretKey, dpk: DerivedPublicKey, derivation_id: Uint8Array): VetKey {
        // Check that c1 and c2 have the same discrete logarithm, ie that e(c1, g2) == e(g1, c2)

        const g1 = bls12_381.G1.ProjectivePoint.BASE;
        const neg_g2 = bls12_381.G2.ProjectivePoint.BASE.negate();
        const gt_one = bls12_381.fields.Fp12.ONE;

        const c1_c2 = bls12_381.pairingBatch([ { g1: this.#c1, g2: neg_g2 }, { g1: g1, g2: this.#c2 }]);

        if(!bls12_381.fields.Fp12.eql(c1_c2, gt_one)) {
            throw new Error("Invalid VetKey");
        }

        // Compute the purported vetkd k
        const c1_tsk = this.#c1.multiply(bls12_381.G1.normPrivateKeyToScalar(tsk.getSecretKey()));
        const k = this.#c3.subtract(c1_tsk);

        // Verify that k is a valid BLS signature
        const msg = augmentedHashToG1(dpk, derivation_id);
        const check = bls12_381.pairingBatch([{ g1: k, g2: neg_g2}, { g1: msg, g2: dpk.getPoint() }]);

        const valid = bls12_381.fields.Fp12.eql(check, gt_one);

        if(valid) {
            return new VetKey(k);
        } else {
            throw new Error("Invalid VetKey");
        }
    }
}

/* IBE (Identity Based Encryption) helper functions, not exported */

enum IbeDomainSeparators {
    HashToMask = "ic-crypto-vetkd-bls12-381-ibe-hash-to-mask",
    MaskSeed = "ic-crypto-vetkd-bls12-381-ibe-mask-seed",
    // Note that the messge length is appended to this
    MaskMsg = "ic-crypto-vetkd-bls12-381-ibe-mask-msg-",
}

function hashToMask(seed: Uint8Array, msg: Uint8Array): bigint {
    const ro_input = new Uint8Array([ ...seed, ...msg]);
    return hashToScalar(ro_input, IbeDomainSeparators.HashToMask);
}

function xorBuf(a: Uint8Array, b: Uint8Array): Uint8Array {
    if(a.length !== b.length) {
        throw new Error("xorBuf arguments should have the same length");
    }
    const c = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++) {
        c[i] = a[i] ^ b[i];
    }
    return c;
}

function maskSeed(seed: Uint8Array, t: Uint8Array): Uint8Array {
    if(t.length !== 576) {
        throw new Error("Unexpected size for Gt element");
    }
    const mask = deriveSymmetricKey(t, IbeDomainSeparators.MaskSeed, seed.length);
    return xorBuf(mask, seed);
}

function maskMsg(msg: Uint8Array, seed: Uint8Array): Uint8Array {
    const domain_sep = IbeDomainSeparators.MaskMsg.concat(msg.length.toString());
    const xof_seed = deriveSymmetricKey(seed, domain_sep, 32);

    const mask = shake256(xof_seed, { dkLen: msg.length });

    return xorBuf(msg, mask);
}

function serializeGtElem(gt: Fp12): Uint8Array {
    // noble-curves formats the Gt element bytes in reverse order
    const enc = bls12_381.fields.Fp12.toBytes(gt);

    const bytes = new Uint8Array(576);

    const shuffle = [11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];

    for (let i = 0; i < 12; ++i) {
        const idx = shuffle[i];
        for (let j = 0; j < 48; ++j) {
            bytes[48*i + j] = enc[48*idx + j];
        }
    }

    return bytes;
}

function isEqual(x: Uint8Array, y: Uint8Array): boolean {
    if (x.length !== y.length) {
        return false
    }

    let diff = 0;
    for (let i = 0; i < x.length; ++i) {
        diff |= x[i] ^ y[i];
    }
    return (diff == 0);
}

const SEED_BYTES = 32;

/**
 * IBE (Identity Based Encryption)
 */
export class IdentityBasedEncryptionCiphertext {
    readonly #c1: G2Point;
    readonly #c2: Uint8Array;
    readonly #c3: Uint8Array;

    /**
     * Serialize the IBE ciphertext to a bytestring
     */
    serialize(): Uint8Array {
        const c1bytes = this.#c1.toRawBytes(true);
        return new Uint8Array([...c1bytes, ...this.#c2, ...this.#c3]);
    }

    /**
     * Deserialize an IBE ciphertext
     */
    static deserialize(bytes: Uint8Array): IdentityBasedEncryptionCiphertext {
        if(bytes.length < G2_BYTES + SEED_BYTES) {
            throw new Error("Invalid IBE ciphertext");
        }

        const c1 = bls12_381.G2.ProjectivePoint.fromHex(bytes.subarray(0, G2_BYTES));
        const c2 = bytes.subarray(G2_BYTES, G2_BYTES + SEED_BYTES);
        const c3 = bytes.subarray(G2_BYTES + SEED_BYTES);

        return new IdentityBasedEncryptionCiphertext(c1, c2, c3);
    }

    /**
     * Encrypt a message using IBE, returning the ciphertext
     *
     * The seed parameter must be a randomly generated value of exactly 32 bytes,
     * that was generated just for this one message. Using it for a second message,
     * or for any other purposes, compromises the security of the IBE scheme.
     *
     * Any user who is able to retrieve the VetKey for the specified
     * derived public key and derivation_id will be able to decrypt
     * this message.
     */
    static encrypt(dpk: DerivedPublicKey,
                   derivation_id: Uint8Array,
                   msg: Uint8Array,
                   seed: Uint8Array): IdentityBasedEncryptionCiphertext {

        if(seed.length !== SEED_BYTES) {
            throw new Error("IBE seed must be exactly SEED_BYTES long");
        }

        const t = hashToMask(seed, msg);
        const pt = augmentedHashToG1(dpk, derivation_id);
        const tsig = bls12_381.fields.Fp12.pow(bls12_381.pairing(pt, dpk.getPoint()), t);

        const c1 = bls12_381.G2.ProjectivePoint.BASE.multiply(t);
        const c2 = maskSeed(seed, serializeGtElem(tsig))
        const c3 = maskMsg(msg, seed);

        return new IdentityBasedEncryptionCiphertext(c1, c2, c3);
    }

    /**
     * Decrypt an IBE ciphertext, returning the message
     */
    decrypt(vetkd: VetKey): Uint8Array {
        const k_c1 = bls12_381.pairing(vetkd.getPoint(), this.#c1);

        const seed = maskSeed(this.#c2, serializeGtElem(k_c1));

        const msg = maskMsg(this.#c3, seed);

        const t = hashToMask(seed, msg);

        const g2_t = bls12_381.G2.ProjectivePoint.BASE.multiply(t);

        const valid = isEqual(g2_t.toRawBytes(true), this.#c1.toRawBytes(true));

        if(valid) {
            return msg;
        } else {
            throw new Error("Decryption failed");
        }
    }

    /**
     * Private constructor
     */
    private constructor(c1: G2Point, c2: Uint8Array, c3: Uint8Array) {
        this.#c1 = c1;
        this.#c2 = c2;
        this.#c3 = c3;
    }
}
